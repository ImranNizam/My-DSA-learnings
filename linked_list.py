# -*- coding: utf-8 -*-
"""Linked list.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1D6HdvCAapy1Zd3VcemX-wotxxNMajvgM
"""

#This is to create the nodes of the linked list.
class node:
  def __init__(self, value):
    self.value = value
    self.next = None

#This class will help us to chain the nodes and to perform various activities accorss those nodes.
class linked_list:
  head = None

  def print_linkedlist(self):
    temp = self.head
    while temp != None:
      print(temp.value, end=' ')
      temp = temp.next

  def insert(self, value):
    if self.head == None:
      self.head = node(value)
      return

    temp = self.head
    while temp.next != None:
      temp = temp.next
    temp.next = node(value)

  def insert_at_head(self, value):
    temp = node(value)
    temp.next = self.head
    self.head = temp

  def insert_at_position(self, value, position):
    if position == 1:
      self.insert_at_head(value)
      return
    temp = self.head
    count = 2
    while count < position and temp != None:
      count += 1
      temp = temp.next
    if count < position:
      print('The given position is greater than the length of the list.')
      return
    rest = temp.next
    temp.next = node(value)
    temp.next.next = rest

  def delete_at_position(self, position):
      if position == 1:
        self.head = self.head.next
        return
      temp = self.head
      count = 2
      while count < position and temp != None:
        count += 1
        temp = temp.next
      if count < position:
        print('The given position is greater than the length of the list.')
        return
      temp.next = temp.next.next

  def middle(self):
     temp_1 = self.head
     temp_2 = self.head
     while temp_1 and temp_1.next != None:
      temp_1 = temp_1.next.next
      temp_2 = temp_2.next
     return temp_2.value

  def reverse(self):
    prev = None
    curr = self.head
    while curr != None:
      next_node = curr.next
      curr.next = prev
      prev = curr
      curr = next_node
    self.head = prev

#This function will help to detect and delete any cycle if present in the linked list.
  def detect_delete_cycle(self):
    slow = self.head.next
    fast = self.head.next.next
    while slow != fast and slow != None and fast != None and fast.next != None:
      slow = slow.next
      fast = fast.next.next
    if slow == fast:
      fast = self.head
      while slow.next != fast.next:
        slow = slow.next
        fast = fast.next
      slow.next = None
      return True
    return False

  def middle_for_mergesort(self, head):
     if head == None:
      return head
     slow = head
     fast = head
     while fast.next != None and fast.next.next != None:
      fast = fast.next.next
      slow = slow.next
     return slow

  def merge(self, head, tomergehead):
    headA = head
    headB = tomergehead
    temp = node(0)
    tail = temp

    while True:
      if headA == None:
        tail.next = headB
        break
      if headB == None:
        tail.next = headA
        break
      if headA.value < headB.value:
        tail.next = headA
        headA = headA.next
      else:
        tail.next = headB
        headB = headB.next
      tail = tail.next
    return temp.next

#This function will provide the sorted list of the linked list using merge sort.
  def mergesort(self, head):
    if head == None or head.next == None:
      return head
    middle = self.middle_for_mergesort(head)
    nexttomiddle = middle.next
    middle.next = None
    left = self.mergesort(head)
    right = self.mergesort(nexttomiddle)
    sortedlinkedlist = self.merge(left, right)
    return sortedlinkedlist

a = linked_list()
a.insert(1)
a.insert(3)
a.insert(2)
a.insert(4)
a.print_linkedlist()
a.mergesort(a.head)
a.print_linkedlist()