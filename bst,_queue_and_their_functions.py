# -*- coding: utf-8 -*-
"""BST, Queue and their functions.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14-SVC13rHfylsX9JAiBCgm3dZsJLXUmo
"""

#This class is created in order to create the objects/Nodes of the trees.
class Node:
  def __init__(self, value):
    self.value = value
    self.left = None
    self.right = None
    #self.orientation = 0  Uncomment this to use the top and bottom view functions.

#Queue class is created in order to perform vaious tasks with trees.
class queue:
  def __init__(self):
    self.queue = []
    self.size = 0

  def push(self, value):
    self.queue.append(value)
    self.size += 1

  def pop(self):
    reversed = self.queue[::-1]
    removed = reversed.pop()
    self.queue = reversed[::-1]
    self.size -= 1
    return removed

  def peek(self):
    first_element = self.queue[0]
    try:
     return first_element.value
    except:
      return first_element

  def is_empty(self):
    if self.size == 0:
      return True
    return False

#This is a Binary Search Tree, where the condition that
#left child should be less in value than the parent and right child should be greater in value than parent will apply.
class BST:
  def __init__(self):
    self.root = None

  def search(self, value):
    answer = recursive_search(self.root, value)
    return answer

  def insert(self, value):
    if self.root == None:
      self.root = Node(value)
      return
    recursive_search_for_insertion(self.root, value)

  def delete(self, value):
    if self.search(value) == False:
      return print('No such node present.')
    recursive_search_for_deletion(self.root, value)

#Inorder of the BST helps to trevarse and print the values of the tree in an inorder manner i.e. Left children will all be in the left side and
#the same for right children as well.
  def BST_inorder(self):
    bst_inorder_helper(self.root)

#This is as same as Inorder except that it will print left children first and parent and the right children.
  def BST_preorder(self):
    bst_preorder_helper(self.root)

#The change in this treversal compared to the previous two is that, it will print parent once it is done with both the left and right children.
  def BST_postorder(self):
    bst_postorder_helper(self.root)

#This is another type of treversal where the nodes are printed according to their level in the tree. (e.g. Parent, then children, then their children, etc.)
  def BST_levelorder(self):
    bst_levelorder_helper(self.root)

#On producing a preorder list and an inorder list, this function can create a BST.
  def BST_constructor(self, preorderlist):
    ranges = [-100, 100]
    self.root = bst_construction_helper(preorderlist, ranges)

index = 0
def bst_construction_helper(preorderlist, ranges):
  global index
  if index >= len(preorderlist):
    return None
  currEle = preorderlist[index]
  if currEle <= ranges[0] or currEle >= ranges[1]:
    return None
  currNode = Node(currEle)
  index += 1
  temp = ranges.copy()
  temp[1] = currNode.value
  currNode.left = bst_construction_helper(preorderlist, temp)
  temp = ranges.copy()
  temp[0] = currNode.value
  currNode.right = bst_construction_helper(preorderlist, temp)
  return currNode

def bst_levelorder_helper(node):
  myqueue = queue()
  myqueue.push(node)
  while myqueue.is_empty() == False:
    popped = myqueue.pop()
    print(popped.value, end=' ')
    if popped.left != None:
      myqueue.push(popped.left)
    if popped.right != None:
      myqueue.push(popped.right)

def bst_inorder_helper(node):
  if node == None:
    return
  bst_inorder_helper(node.left)
  print(node.value, end=' ')
  bst_inorder_helper(node.right)

def bst_preorder_helper(node):
  if node == None:
    return
  print(node.value, end=' ')
  bst_preorder_helper(node.left)
  bst_preorder_helper(node.right)

def bst_postorder_helper(node):
  if node == None:
    return
  bst_postorder_helper(node.left)
  bst_postorder_helper(node.right)
  print(node.value, end=' ')

def recursive_search_for_deletion(node, num):
  if node.value < num:
    if node.right.value == num:
      target = node.right
      if target.left == None and target.right == None:
        target = None
        return
      if target.left == None or target.right == None:
        if target.left == None:
          target = target.right
          return
        target = target.left
        return
      replacement = findmin(target.right)
      recursive_search_for_deletion(node, replacement)
      target.value = replacement
    else:
      recursive_search_for_deletion(node.right, num)
  else:
    if node.left.value == num:
      target = node.left
      if target.left == None and target.right == None:
        target = None
        return
      if target.left == None or target.right == None:
        if target.left == None:
          target = target.right
          return
        target = target.left
        return
      replacement = findmin(target.right)
      recursive_search_for_deletion(node, replacement)
      target.value = replacement
    else:
      recursive_search_for_deletion(node.left, num)

def findmin(node):
  if node.left == None:
    return node.value
  return findmin(node.left)

def recursive_search_for_insertion(node, value):
  if node.value > value:
    if node.left == None:
      node.left = Node(value)
      return
    return recursive_search_for_insertion(node.left, value)
  if node.right == None:
    node.right = Node(value)
    return
  return recursive_search_for_insertion(node.right, value)

def recursive_search(node, value):
  if node == None:
    return False
  if node.value == value:
    return True
  if node.value > value:
    return recursive_search(node.left, value)
  return recursive_search(node.right, value)

mytree = Node(1)
mytree.left = Node(2)
mytree.right = Node(3)
mytree.left.left = Node(4)
mytree.left.right = Node(5)
mytree.right.right = Node(6)

def inorder(node):
  if node == None:
    return
  inorder(node.left)
  print(node.value, end = ' ')
  inorder(node.right)

def preorder(node):
  if node == None:
    return
  print(node.value, end = ' ')
  preorder(node.left)
  preorder(node.right)

def postorder(node):
  if node == None:
    return
  postorder(node.left)
  postorder(node.right)
  print(node.value, end=' ')

def levelorder(node):
  myqueue = queue()
  myqueue.push(node)
  while myqueue.is_empty() == False:
    popped = myqueue.pop()
    if popped.left != None:
      myqueue.push(popped.left)
    if popped.right != None:
      myqueue.push(popped.right)
    print(popped.value, end=' ')

def construct_with_preorder(preorderlist, inorderlist, start, end):
  global index
  if start > end:
    return
  currEle = preorderlist[index]
  index += 1
  inorderpos = inorderlist.index(currEle)
  currNode = Node(currEle)
  currNode.left = construct_with_preorder(preorderlist, inorderlist, start, inorderpos - 1)
  currNode.right = construct_with_preorder(preorderlist, inorderlist, inorderpos + 1, end)
  return currNode

def construct_with_postorder(postorderlist, inorderlist, start, end):
  global index
  if start > end:
    return
  currEle = postorderlist[index]
  index -= 1
  inorderpos = inorderlist.index(currEle)
  currNode = Node(currEle)
  currNode.right = construct_with_postorder(postorderlist, inorderlist, inorderpos + 1, end)
  currNode.left = construct_with_postorder(postorderlist, inorderlist, start, inorderpos - 1)
  return currNode

#This will provide the nodes which can be seen from the left side of the tree i.e first nodes of each layer of the tree.
def leftview(node):
  myqueue = queue()
  myqueue.push(None)
  myqueue.push(node)
  while True:
    popped = myqueue.pop()
    if popped == None:
      if myqueue.is_empty() == True:
        return
      myqueue.push(None)
      popped = myqueue.pop()
      print(popped.value)
    if popped.left != None:
      myqueue.push(popped.left)
    if popped.right != None:
      myqueue.push(popped.right)

#This will provide the nodes which can be seen from the right side of the tree i.e last nodes of each layer of the tree.
def rightview(node):
  myqueue = queue()
  myqueue.push(None)
  myqueue.push(node)
  while True:
    popped = myqueue.pop()
    if popped == None:
      if myqueue.is_empty() == True:
        return
      myqueue.push(None)
      continue
    if myqueue.peek() == None:
      print(popped.value)
    if popped.left != None:
      myqueue.push(popped.left)
    if popped.right != None:
      myqueue.push(popped.right)

#This will provide the nodes which can be seen from top of the tree i.e first nodes of each orientation of the tree.
def topview(node):           #Uncomment self.orientation in Node class to use this function.
  orientation_list = {}
  myqueue = queue()
  myqueue.push(None)
  myqueue.push(node)
  while True:
    popped = myqueue.pop()
    if popped == None:
      if myqueue.is_empty() == True:
        break
      myqueue.push(None)
      continue
    if popped.orientation not in orientation_list:
      orientation_list[popped.orientation] = popped.value
    if popped.left != None:
      popped.left.orientation = popped.orientation -1
      myqueue.push(popped.left)
    if popped.right != None:
      popped.right.orientation = popped.orientation + 1
      myqueue.push(popped.right)
  for i in sorted(orientation_list):
    print(orientation_list[i], end = ' ')

#This will provide the nodes which can be seen from bottom of the tree i.e last nodes of each orientation of the tree.
def bottomview(node):      #Uncomment self.orientation in Node class to use this function.
  orientation_list = {}
  myqueue = queue()
  myqueue.push(None)
  myqueue.push(node)
  while True:
    popped = myqueue.pop()
    if popped == None:
      if myqueue.is_empty() == True:
        break
      myqueue.push(None)
      continue
    orientation_list[popped.orientation] = popped.value
    if popped.left != None:
      popped.left.orientation = popped.orientation -1
      myqueue.push(popped.left)
    if popped.right != None:
      popped.right.orientation = popped.orientation + 1
      myqueue.push(popped.right)
  for i in sorted(orientation_list):
    print(orientation_list[i], end=' ')

#This will provide the number of seconds it take to reach the last node from a selected node. Each layer form the selected node will take one second.
def burning_tree(node, target):
  parent = {}
  myqueue = queue()
  myqueue.push(node)
  while myqueue.is_empty() == False:
    popped = myqueue.pop()
    if popped.left != None:
      parent[popped.left] = popped
      myqueue.push(popped.left)
    if popped.right != None:
      parent[popped.right] = popped
      myqueue.push(popped.right)
  burned = []
  ans = 0
  myqueue.push(None)
  myqueue.push(target)
  while True:
    popped = myqueue.pop()
    if popped == None:
      if myqueue.is_empty() == True:
        return ans
      myqueue.push(None)
      ans += 1
      continue
    burned.append(popped)
    if popped in parent and parent[popped] not in burned:
      myqueue.push(parent[popped])
    if popped.left != None and popped.left not in burned:
      myqueue.push(popped.left)
    if popped.right != None and popped.right not in burned:
      myqueue.push(popped.right)

myBST = BST()
myBST.insert(5)
myBST.insert(8)
myBST.insert(11)
myBST.insert(2)
myBST.insert(1)
myBST.insert(3)
newBST = BST()
newBST.BST_constructor([5, 2, 1, 3, 8, 11])
newBST.BST_preorder()